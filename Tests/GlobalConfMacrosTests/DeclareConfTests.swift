import XCTest

import SwiftSyntax
import SwiftSyntaxBuilder
import SwiftSyntaxMacros
import SwiftSyntaxMacrosTestSupport



/* Macro implementations build for the host, so the corresponding module is not available when cross-compiling.
 * Cross-compiled tests may still make use of the macro itself in end-to-end tests. */
#if canImport(GlobalConfMacros)
import GlobalConfMacros

private let testMacros: [String: Macro.Type] = [
	"declareConfKey":           DeclareConfMacro.self,
	"declareConfFactoryKey":    DeclareConfMacro.self,
	"declareServiceKey":        DeclareConfMacro.self,
	"declareServiceFactoryKey": DeclareConfMacro.self,
]
#endif


final class DeclareConfTests : XCTestCase {
	
	func testBasicUsage() throws {
#if canImport(GlobalConfMacros)
		assertMacroExpansion("""
				import Configuration
				extension ConfKeys {
					#declareConfKey("myBool", Bool.self, "MyBoolConfKey", defaultValue: true)
				}
				""",
			expandedSource: #"""
				import Configuration
				extension ConfKeys {
					public enum MyBoolConfKey : ConfKey {
						public typealias Value = Bool
						public static let defaultValue: Bool! = .some(true)
					}
					public var myBool: MyBoolConfKey.Type {
					    MyBoolConfKey.self
					}
				}
				"""#,
			macros: testMacros
		)
#else
		throw XCTSkip("Macros are only supported when running tests for the host platform.")
#endif
	}
	
	func testBasicInternalUsage() throws {
#if canImport(GlobalConfMacros)
		assertMacroExpansion("""
				import Configuration
				extension ConfKeys {
					#declareConfKey(visibility: .internal, "myBool", Bool.self, "MyBoolConfKey", defaultValue: true)
				}
				""",
			expandedSource: #"""
				import Configuration
				extension ConfKeys {
					internal enum MyBoolConfKey : ConfKey {
						internal typealias Value = Bool
						internal static let defaultValue: Bool! = .some(true)
					}
					internal var myBool: MyBoolConfKey.Type {
					    MyBoolConfKey.self
					}
				}
				"""#,
			macros: testMacros
		)
#else
		throw XCTSkip("Macros are only supported when running tests for the host platform.")
#endif
	}
	
	func testInternalFQNUsage() throws {
#if canImport(GlobalConfMacros)
		assertMacroExpansion("""
				import Configuration
				extension ConfKeys {
					#declareConfKey(visibility: GlobalConfModule.DeclarationVisibility.internal, "myBool", Bool.self, "MyBoolConfKey", defaultValue: true)
				}
				""",
			expandedSource: #"""
				import Configuration
				extension ConfKeys {
					internal enum MyBoolConfKey : ConfKey {
						internal typealias Value = Bool
						internal static let defaultValue: Bool! = .some(true)
					}
					internal var myBool: MyBoolConfKey.Type {
					    MyBoolConfKey.self
					}
				}
				"""#,
			macros: testMacros
		)
#else
		throw XCTSkip("Macros are only supported when running tests for the host platform.")
#endif
	}
	
	func testBasicUsageNonStandardContainer() throws {
#if canImport(GlobalConfMacros)
		assertMacroExpansion("""
				import Configuration
				extension ConfKeys.MyLib {
					#declareConfKey("myBool", Bool.self, on: MainActor.self, defaultValue: true)
				}
				""",
			expandedSource: #"""
				import Configuration
				extension ConfKeys.MyLib {
					public enum ConfKey_myBool : ConfKeyMainActor {
						public typealias Value = Bool
						public static let defaultValue: Bool! = .some(true)
					}
					public var myBool: ConfKey_myBool.Type {
					    ConfKey_myBool.self
					}
				}
				"""#,
			macros: testMacros
		)
#else
		throw XCTSkip("Macros are only supported when running tests for the host platform.")
#endif
	}
	
	func testBasicUsageNonIsolated() throws {
#if canImport(GlobalConfMacros)
		assertMacroExpansion("""
				extension ConfKeys {
					#declareConfKey("oslog", OSLog?.self, unsafeNonIsolated: true, defaultValue: .default)
				}
				""",
			expandedSource: /* Not sure the autogenerated name will always stay the same… */#"""
				extension ConfKeys {
					public struct __macro_local_5OSLogfMu_ : @unchecked Sendable {
						public let value: OSLog?
						public init(_ value: OSLog?) {
							self.value = value
						}
					}
				
					public enum ConfKey_oslog : ConfKey {
						public typealias Value = __macro_local_5OSLogfMu_
						public static let defaultValue: __macro_local_5OSLogfMu_! = .some(__macro_local_5OSLogfMu_(.default))
					}
					public var oslog: ConfKey_oslog.Type {
						ConfKey_oslog.self
					}
				}
				"""#,
			macros: testMacros,
			indentationWidth: .tabs(1)
		)
#else
		throw XCTSkip("Macros are only supported when running tests for the host platform.")
#endif
	}
	
	func testUsageTwoNonIsolated() throws {
#if canImport(GlobalConfMacros)
		assertMacroExpansion("""
				extension ConfKeys {
					#declareConfKey("fileManager1", FileManager.self, unsafeNonIsolated: true, defaultValue: .default)
					#declareConfKey("fileManager2", FileManager.self, unsafeNonIsolated: true, defaultValue: .default)
				}
				""",
			expandedSource: /* Not sure the autogenerated name will always stay the same… */#"""
				extension ConfKeys {
					public struct __macro_local_11FileManagerfMu_ : @unchecked Sendable {
						public let value: FileManager
						public init(_ value: FileManager) {
							self.value = value
						}
					}
				
					public enum ConfKey_fileManager1 : ConfKey {
						public typealias Value = __macro_local_11FileManagerfMu_
						public static let defaultValue: __macro_local_11FileManagerfMu_! = .some(__macro_local_11FileManagerfMu_(.default))
					}
					public var fileManager1: ConfKey_fileManager1.Type {
						ConfKey_fileManager1.self
					}
					public struct __macro_local_11FileManagerfMu0_ : @unchecked Sendable {
						public let value: FileManager
						public init(_ value: FileManager) {
							self.value = value
						}
					}
				
					public enum ConfKey_fileManager2 : ConfKey {
						public typealias Value = __macro_local_11FileManagerfMu0_
						public static let defaultValue: __macro_local_11FileManagerfMu0_! = .some(__macro_local_11FileManagerfMu0_(.default))
					}
					public var fileManager2: ConfKey_fileManager2.Type {
						ConfKey_fileManager2.self
					}
				}
				"""#,
			macros: testMacros,
			indentationWidth: .tabs(1)
		)
#else
		throw XCTSkip("Macros are only supported when running tests for the host platform.")
#endif
	}
	
	func testBasicConfFactoryUsage() throws {
#if canImport(GlobalConfMacros)
		assertMacroExpansion("""
				extension ConfKeys {
					#declareConfFactoryKey("randomInt", Int.self, defaultValue: { .random(in: 0..<42) })
				}
				""",
			expandedSource: #"""
				extension ConfKeys {
					public enum ConfKey_randomInt : ConfKey {
						public typealias Value = (@Sendable () -> Int)
						public static let defaultValue: (@Sendable () -> Int)! = .some({
						        .random(in: 0 ..< 42)
						    })
					}
					public var randomInt: ConfKey_randomInt.Type {
					    ConfKey_randomInt.self
					}
				}
				"""#,
			macros: testMacros
		)
#else
		throw XCTSkip("Macros are only supported when running tests for the host platform.")
#endif
	}
	
	func testBasicServiceFactoryUsage() throws {
#if canImport(GlobalConfMacros)
		assertMacroExpansion("""
				extension ConfKeys {
					#declareServiceFactoryKey("amazingBool", Bool.self, defaultValue: { true })
				}
				""",
			expandedSource: #"""
				extension ConfKeys {
					public enum ConfKey_amazingBool : ConfKey {
						public typealias Value = (@Sendable () -> Bool)
						public static let defaultValue: (@Sendable () -> Bool)! = {
						    true
						}
					}
					public var amazingBool: ConfKey_amazingBool.Type {
					    ConfKey_amazingBool.self
					}
				}
				"""#,
			macros: testMacros
		)
#else
		throw XCTSkip("Macros are only supported when running tests for the host platform.")
#endif
	}
	
	func testUsageWithSpaceBeforeSelf() throws {
#if canImport(GlobalConfMacros)
		assertMacroExpansion("""
				extension ConfKeys {
					#declareServiceKey("oslog", OSLog?   .self, unsafeNonIsolated: true, defaultValue: .default)
				}
				""",
			expandedSource: #"""
				extension ConfKeys {
					public struct __macro_local_5OSLogfMu_ : @unchecked Sendable {
						public let value: OSLog?
						public init(_ value: OSLog?) {
							self.value = value
						}
					}
				
					public enum ConfKey_oslog : ConfKey {
						public typealias Value = __macro_local_5OSLogfMu_
						public static let defaultValue: __macro_local_5OSLogfMu_! = __macro_local_5OSLogfMu_(.default)
					}
					public var oslog: ConfKey_oslog.Type {
						ConfKey_oslog.self
					}
				}
				"""#,
			macros: testMacros,
			indentationWidth: .tabs(1)
		)
#else
		throw XCTSkip("Macros are only supported when running tests for the host platform.")
#endif
	}
	
	func testUsageWithoutConfKey() throws {
#if canImport(GlobalConfMacros)
		/* Note I’m not sure the generated name is stable… */
		assertMacroExpansion("""
				extension ConfKeys {
					#declareServiceKey(nil, MyService.self, "MyServiceConfKey", defaultValue: .init())
				}
				""",
			expandedSource: #"""
				extension ConfKeys {
					public enum MyServiceConfKey : ConfKey {
						public typealias Value = MyService
						public static let defaultValue: MyService! = .init()
					}
				}
				"""#,
			macros: testMacros
		)
#else
		throw XCTSkip("Macros are only supported when running tests for the host platform.")
#endif
	}
	
	func testUsageWithoutConfKeyOrType() throws {
#if canImport(GlobalConfMacros)
		/* Note I’m not sure the generated name is stable… */
		assertMacroExpansion("""
				extension ConfKeys {
					#declareServiceKey(nil, MyService.self, defaultValue: .init())
				}
				""",
			expandedSource: #"""
				extension ConfKeys {
					public enum __macro_local_7ConfKeyfMu_ : ConfKey {
						public typealias Value = MyService
						public static let defaultValue: MyService! = .init()
					}
				}
				"""#,
			macros: testMacros
		)
#else
		throw XCTSkip("Macros are only supported when running tests for the host platform.")
#endif
	}
	
}
